<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ice Growth Forecast</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.4.0/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        #map {
            height: 500px;
        }
        #controls {
            margin: 20px 0;
        }
        .chart-container {
            width: 100%;
            max-width: 600px;
            margin: 20px auto;
        }
        .toggle-button {
            display: inline-block;
            padding: 5px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            background-color: #f0f0f0;
        }
        .toggle-button.active {
            background-color: #007bff;
            color: white;
        }
        h1 {
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Ice Growth Forecast Tool</h1>
    <div id="map"></div>
    <div id="controls">
        <label for="search-location">Search Location:</label>
        <input type="text" id="search-location" placeholder="Enter a location" style="width: 300px;">
        <button id="search-button">Search</button>
        <br><br>
        <label for="coordinates">Coordinates:</label>
        <input type="text" id="coordinates" placeholder="Latitude, Longitude" style="width: 300px;">
        <br><br>
        <label for="start-date">Start Date:</label>
        <input type="date" id="start-date">
        <label for="end-date">End Date:</label>
        <input type="date" id="end-date">
        <br><br>
        <label for="verified-thickness">Verified Ice Thickness:</label>
        <input type="number" id="verified-thickness" placeholder="Centimeters">
        <label for="verified-date">Date of Measurement:</label>
        <input type="date" id="verified-date">
        <br><br>
        <label>Units:</label>
        <div id="unit-toggle" class="toggle-button active">Metric</div>
        <div id="unit-toggle-imperial" class="toggle-button">Imperial</div>
        <br><br>
        <button id="fetch-weather">Fetch Ice Growth Data</button>
    </div>
    <div id="results">
        <h2>Results</h2>
        <div id="forecast-cards"></div>
        <div class="chart-container">
            <canvas id="iceGrowthChart"></canvas>
        </div>
    </div>

    <script>
        const map = L.map('map').setView([42.821878, -112.403065], 30); // Default to Edson Fichter Pond
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
        }).addTo(map);

        let selectedLatLng;
        const coordinatesInput = document.getElementById('coordinates');
        const searchLocationInput = document.getElementById('search-location');
        const searchButton = document.getElementById('search-button');
        const startDateInput = document.getElementById('start-date');
        const endDateInput = document.getElementById('end-date');
        const verifiedThicknessInput = document.getElementById('verified-thickness');
        const verifiedDateInput = document.getElementById('verified-date');
        const unitToggleMetric = document.getElementById('unit-toggle');
        const unitToggleImperial = document.getElementById('unit-toggle-imperial');
        const forecastCards = document.getElementById('forecast-cards');
        let marker;
        let isMetric = true; // Default unit is Metric
        let iceGrowthChart; // Reference to the Chart.js instance

        const toggleUnits = (metric) => {
            isMetric = metric;
            unitToggleMetric.classList.toggle('active', metric);
            unitToggleImperial.classList.toggle('active', !metric);
            verifiedThicknessInput.placeholder = isMetric ? 'Centimeters' : 'Inches';

            // Update displayed results without refetching
            const forecastDivs = forecastCards.querySelectorAll('div');
            forecastDivs.forEach(div => {
                const paragraphs = div.querySelectorAll('p');
                paragraphs.forEach(p => {
                    const valueMatch = p.textContent.match(/([\d\.]+) (mm|in)/);
                    if (valueMatch) {
                        const value = parseFloat(valueMatch[1]);
                        const unit = valueMatch[2];
                        const convertedValue = unit === 'mm' ? convertThickness(value, false) : convertThickness(value, true);
                        const newUnit = isMetric ? 'mm' : 'in';
                        p.textContent = p.textContent.replace(/([\d\.]+) (mm|in)/, `${convertedValue.toFixed(2)} ${newUnit}`);
                    }
                });
            });
        };

        unitToggleMetric.addEventListener('click', () => toggleUnits(true));
        unitToggleImperial.addEventListener('click', () => toggleUnits(false));

        const convertThickness = (value, toMetric) => {
            return toMetric ? value * 25.4 : value / 25.4; // Convert between inches and millimeters
        };

        const fahrenheitToCelsius = (fahrenheit) => {
            return (fahrenheit - 32) * 5 / 9;
        };

        map.on('click', (e) => {
            selectedLatLng = e.latlng;
            const { lat, lng } = selectedLatLng;

            // Update the coordinates input box
            coordinatesInput.value = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;

            // Add or move the marker
            if (marker) {
                marker.setLatLng(selectedLatLng);
            } else {
                marker = L.marker(selectedLatLng).addTo(map);
            }
        });

        coordinatesInput.addEventListener('change', () => {
            const coords = coordinatesInput.value.split(',').map(c => parseFloat(c.trim()));
            if (coords.length === 2 && !isNaN(coords[0]) && !isNaN(coords[1])) {
                selectedLatLng = { lat: coords[0], lng: coords[1] };

                // Move the marker and center the map
                if (marker) {
                    marker.setLatLng(selectedLatLng);
                } else {
                    marker = L.marker(selectedLatLng).addTo(map);
                }
                map.setView(selectedLatLng, map.getZoom());
            } else {
                alert('Invalid coordinates. Please enter in the format: Latitude, Longitude');
            }
        });

        document.getElementById('fetch-weather').addEventListener('click', async () => {
            if (!selectedLatLng) {
                alert('Please select a location on the map or enter coordinates.');
                return;
            }

            const startDate = startDateInput.value;
            const endDate = endDateInput.value;
            let verifiedThickness = parseFloat(verifiedThicknessInput.value);
            const verifiedDate = verifiedDateInput.value;

            if (!startDate || !endDate) {
                alert('Please select both start and end dates.');
                return;
            }

            if (new Date(startDate) > new Date(endDate)) {
                alert('Start date must be before end date.');
                return;
            }

            if (!isMetric && !isNaN(verifiedThickness)) {
                verifiedThickness = convertThickness(verifiedThickness, true); // Convert to Metric if input is Imperial
            }

            try {
                const { lat, lng } = selectedLatLng;

                // Fetch weather data from Weather.gov API (National Weather Service) for hourly forecast
                const weatherResponse = await axios.get(`https://api.weather.gov/points/${lat},${lng}`);
                const forecastUrl = weatherResponse.data.properties.forecastHourly; // Fetch hourly data
                
                // Fetch hourly forecast data
                const forecastResponse = await axios.get(forecastUrl);
                const forecastData = forecastResponse.data.properties.periods;

                // Filter forecast data to match the range between start and end dates
                const dateRange = [];
                let currentDate = new Date(startDate);
                const endDateObj = new Date(endDate);

                while (currentDate <= endDateObj) {
                    dateRange.push(new Date(currentDate));
                    currentDate.setDate(currentDate.getDate() + 1);
                }

                // Initial thickness
                let initialThickness = verifiedThickness || 0;
                const initialDate = verifiedDate ? new Date(verifiedDate) : new Date(startDate);

                const totalGrowthRate = (initialThickness, hourlyTemperatures) => {
                    let totalGrowth = 0;
                    let totalMelting = 0;

                    // Iterate over hourly temperatures
                    hourlyTemperatures.forEach(forecast => {
                        const avgTemperature = fahrenheitToCelsius(forecast.temperature); // Convert hourly temp to Celsius
                        const fdd = Math.max(0, (0 - avgTemperature)); // Freezing Degree Days (FDD)
                        const pdd = Math.max(0, avgTemperature); // Positive Degree Days (PDD)

                        // Growth rate (simplified Ashton formula)
                        const growthRate = initialThickness < 76.2 // 3 inches
                            ? Math.max(0, (avgTemperature < -1 ? 0.5 : 0) * (Math.abs(avgTemperature + 1)))
                            : Math.max(0, 25 / (15 + initialThickness));

                        // Melting rate (assumed linear relation to PDD)
                        const meltingRate = pdd > 0 ? pdd * 0.2 : 0; // Example: 0.2 mm/°C/hour

                        // Update growth and melting totals
                        totalGrowth += growthRate;
                        totalMelting += meltingRate;
                    });

                    return {
                        growthRate: totalGrowth,
                        meltingRate: totalMelting,
                    };
                };

                const iceGrowthData = [];

                dateRange.forEach(date => {
                    // Find the hourly forecast periods for the current date
                    const hourlyTemperatures = forecastData.filter(forecast => {
                        const forecastDate = new Date(forecast.startTime);
                        return forecastDate.toISOString().split('T')[0] === date.toISOString().split('T')[0];
                    });

                    if (hourlyTemperatures.length === 0) {
                        // If no hourly temperatures found for the date, skip
                        iceGrowthData.push({
                            date: date.toISOString().split('T')[0],
                            growthRate: 0,
                            meltingRate: 0,
                            thickness: initialThickness,
                        });
                        return;
                    }

                    // Calculate the growth and melting rates using hourly data
                    const { growthRate, meltingRate } = totalGrowthRate(initialThickness, hourlyTemperatures);

                    // Adjust thickness based on growth and melting rates
                    initialThickness += growthRate - meltingRate;
                    initialThickness = Math.max(0, initialThickness); // Prevent negative thickness

                    // Push calculated data to iceGrowthData
                    iceGrowthData.push({
                        date: date.toISOString().split('T')[0],
                        growthRate: isMetric ? growthRate : convertThickness(growthRate, false), // Convert units if needed
                        meltingRate: isMetric ? meltingRate : convertThickness(meltingRate, false), // Convert units if needed
                        thickness: isMetric ? initialThickness : convertThickness(initialThickness, false), // Convert units if needed
                    });
                });

                // Display the data and update the chart
                forecastCards.innerHTML = iceGrowthData.map(data => `
                    <div style="border: 1px solid #ccc; padding: 10px; margin: 10px;">
                        <h3>${data.date}</h3>
                        <p>Ice Growth Rate: ${data.growthRate.toFixed(2)} ${isMetric ? 'mm/hour' : 'in/hour'}</p>
                        <p>Ice Melting Rate: ${data.meltingRate.toFixed(2)} ${isMetric ? 'mm/hour' : 'in/hour'}</p>
                        <p>Total Thickness: ${data.thickness.toFixed(2)} ${isMetric ? 'mm' : 'in'}</p>
                    </div>
                `).join('');

                // Prepare data for the chart
                const labels = iceGrowthData.map(data => data.date);
                const growthRates = iceGrowthData.map(data => data.growthRate);
                const meltingRates = iceGrowthData.map(data => data.meltingRate);
                const thicknesses = iceGrowthData.map(data => data.thickness);

                // Destroy existing chart if it exists
                if (iceGrowthChart) {
                    iceGrowthChart.destroy();
                }

                // Create or update the ice growth chart
                const ctx = document.getElementById('iceGrowthChart').getContext('2d');
                iceGrowthChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: `Ice Growth Rate (${isMetric ? 'mm/hour' : 'in/hour'})`,
                                data: growthRates,
                                borderColor: 'rgba(75, 192, 192, 1)',
                                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                                fill: true,
                            },
                            {
                                label: `Ice Melting Rate (${isMetric ? 'mm/hour' : 'in/hour'})`,
                                data: meltingRates,
                                borderColor: 'rgba(192, 192, 75, 1)',
                                backgroundColor: 'rgba(192, 192, 75, 0.2)',
                                fill: true,
                            },
                            {
                                label: `Total Thickness (${isMetric ? 'mm' : 'in'})`,
                                data: thicknesses,
                                borderColor: 'rgba(192, 75, 75, 1)',
                                backgroundColor: 'rgba(192, 75, 75, 0.2)',
                                fill: true,
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                display: true,
                            },
                        },
                    },
                });

            } catch (error) {
                console.error('Error fetching ice growth data:', error);
                alert('Failed to fetch ice growth data. Check console for details.');
            }
        });
    </script>
</body>
</html>
