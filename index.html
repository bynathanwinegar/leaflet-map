<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ice Growth Forecasting</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        #map { height: 400px; }
        table { margin-top: 20px; border-collapse: collapse; width: 100%; }
        th, td { padding: 8px; text-align: left; border: 1px solid #ddd; }
        th { background-color: #f2f2f2; }
        #coordinates-box { margin-top: 10px; }
        input { width: 150px; padding: 5px; }
    </style>
</head>
<body>

    <h2>Ice Growth Forecasting</h2>
    
    <!-- Map Container -->
    <div id="map"></div>
    
    <!-- Coordinates Box -->
    <div id="coordinates-box">
        <label for="latInput">Latitude:</label>
        <input type="text" id="latInput" placeholder="Latitude" readonly>
        <label for="lonInput">Longitude:</label>
        <input type="text" id="lonInput" placeholder="Longitude" readonly>
    </div>

    <!-- Date Range Form -->
    <form id="form">
        <label for="startDate">Start Date:</label>
        <input type="date" id="startDate" required>
        <label for="endDate">End Date:</label>
        <input type="date" id="endDate" required>
        <button type="submit">Publish Results</button>
    </form>

    <div id="iceGrowthResults"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        // Initialize map
        const map = L.map('map').setView([51.505, -0.09], 2); // Default center: World view

        // Add tile layer (OpenStreetMap)
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        let userLat, userLon;
        let userMarker;

        // When the map is clicked, place a pin and display coordinates
        map.on('click', function(e) {
            // If there's an existing marker, remove it
            if (userMarker) {
                map.removeLayer(userMarker);
            }

            // Set new coordinates
            userLat = e.latlng.lat;
            userLon = e.latlng.lng;

            // Add new marker
            userMarker = L.marker([userLat, userLon]).addTo(map);

            // Update the coordinate inputs
            document.getElementById('latInput').value = userLat.toFixed(4);
            document.getElementById('lonInput').value = userLon.toFixed(4);
        });

        // Date range form submission
        document.getElementById('form').addEventListener('submit', function(e) {
            e.preventDefault();
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;

            // Ensure coordinates and date range are provided
            if (userLat && userLon && startDate && endDate) {
                getWeatherData(userLat, userLon, startDate, endDate);
            } else {
                alert('Please select a location and date range.');
            }
        });

        // Fetch weather data from weather.gov API
        function getWeatherData(lat, lon, startDate, endDate) {
            const pointApiUrl = `https://api.weather.gov/points/${lat},${lon}`;

            console.log('Fetching point data for:', lat, lon);  // Debugging log
            console.log('API Endpoint:', pointApiUrl); // Log the full endpoint to verify it's correct

            fetch(pointApiUrl, {
                method: 'GET',
                headers: {
                    'User-Agent': 'IceGrowthForecasting/1.0 (your-email@example.com)',  // Change with your email
                    'Accept': 'application/ld+json'
                }
            })
            .then(response => {
                console.log('Point API Response Status:', response.status);  // Debugging log
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                console.log('Point Data:', data);  // Debugging log
                
                // Extract forecast URL (either forecastHourly or forecast)
                const forecastUrl = data.properties.forecastHourly || data.properties.forecast;
                
                if (!forecastUrl) {
                    throw new Error('No forecast URL found in point data');
                }

                console.log('Using forecast URL:', forecastUrl);  // Debugging log

                // Now fetch the forecast data using the extracted URL
                return fetch(forecastUrl, {
                    method: 'GET',
                    headers: {
                        'User-Agent': 'IceGrowthForecasting/1.0 (your-email@example.com)',  // Change with your email
                        'Accept': 'application/ld+json'
                    }
                });
            })
            .then(response => {
                console.log('Forecast API Response Status:', response.status);  // Debugging log
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                console.log('Forecast Data:', data);  // Debugging log
                const forecast = data.properties.periods;

                if (!forecast || forecast.length === 0) {
                    throw new Error('No forecast data available');
                }

                // Filter forecast data based on the selected date range
                const filteredForecast = forecast.filter(period => {
                    const forecastTime = new Date(period.startTime);
                    return forecastTime >= new Date(startDate) && forecastTime <= new Date(endDate);
                });

                if (filteredForecast.length === 0) {
                    throw new Error('No data available within the selected date range');
                }

                processWeatherForIceGrowth(filteredForecast);
            })
            .catch(err => {
                console.error('Error fetching or processing weather data:', err);
                alert('There was an error fetching the weather data. Please try again.');
            });
        }

        // Process the weather data for ice growth calculation
        function processWeatherForIceGrowth(forecastData) {
            const weatherData = forecastData.map(period => ({
                time: period.startTime,
                temperature: period.temperature, // In Fahrenheit
                windSpeed: parseInt(period.windSpeed.split(' ')[0]), // In mph
                humidity: period.relativeHumidity // In percentage
            }));

            console.log('Processed Weather Data:', weatherData);  // Debugging log

            // Calculate ice growth using weather data
            calculateIceGrowth(weatherData);
        }

        // Calculate ice growth or decay based on weather data
        function calculateIceGrowth(weatherData) {
            const iceGrowthData = [];

            weatherData.forEach(day => {
                const { time, temperature, windSpeed, humidity } = day;
                let iceGrowthRate = 0;

                if (temperature <= 32) {
                    iceGrowthRate = Math.pow(32 - temperature, 1.5); // Basic ice growth model
                } else if (temperature > 32 && temperature <= 40) {
                    iceGrowthRate = -(temperature - 32); // Basic ice decay model
                }

                iceGrowthRate -= windSpeed * 0.1; // Wind slows growth
                iceGrowthRate += humidity * 0.05; // Humidity accelerates growth

                iceGrowthData.push({
                    time: new Date(time).toLocaleString(),
                    temperature: temperature,
                    iceGrowthRate: iceGrowthRate
                });
            });

            displayIceGrowthResults(iceGrowthData);
        }

        // Display ice growth results in a table
        function displayIceGrowthResults(iceGrowthData) {
            if (iceGrowthData.length === 0) {
                alert('No ice growth data available for the selected period.');
                return;
            }

            const table = document.createElement('table');
            const headerRow = document.createElement('tr');
            headerRow.innerHTML = '<th>Time</th><th>Temperature (Â°F)</th><th>Ice Growth Rate (inches/day)</th>';
            table.appendChild(headerRow);

            iceGrowthData.forEach(entry => {
                const row = document.createElement('tr');
                row.innerHTML = `<td>${entry.time}</td><td>${entry.temperature}</td><td>${entry.iceGrowthRate.toFixed(2)}</td>`;
                table.appendChild(row);
            });

            const resultsContainer = document.getElementById('iceGrowthResults');
            resultsContainer.innerHTML = ''; // Clear previous results
            resultsContainer.appendChild(table); // Display new table
        }
    </script>
</body>
</html>
